# 回调函数与钩子函数详解

## 回调函数（Callback Functions）

回调函数是一种作为参数传递给其他函数的函数，当特定事件或条件发生时，该函数会被调用（"回调"）。

### 核心概念：
1. **传递函数作为参数**：将函数作为参数传递给另一个函数
2. **异步执行**：在特定事件或条件满足时执行
3. **解耦**：调用者与被调用者之间解耦
4. **控制反转**：被调用函数决定何时调用回调函数

### 示例代码：
```python
# 回调函数示例
def process_data(data, callback):
    """处理数据并调用回调函数"""
    print(f"处理数据: {data}")
    # 处理完成后调用回调
    callback(data.upper())

# 回调函数定义
def handle_result(result):
    """处理结果"""
    print(f"处理结果: {result}")

# 使用回调
process_data("hello world", handle_result)
```

### 输出：
```
处理数据: hello world
处理结果: HELLO WORLD
```

### 常见应用场景：
- 事件处理（GUI编程）
- 异步操作（网络请求、文件I/O）
- 排序算法中的比较函数
- 定时器任务

## 钩子函数（Hook Functions）

钩子函数是一种在程序执行到特定位置时被自动调用的函数，通常用于扩展或修改程序行为。

### 核心概念：
1. **预设点**：在代码中预设的特定位置（钩子点）
2. **插入点**：允许外部代码在这些点上"挂入"自定义逻辑
3. **扩展性**：在不修改原始代码的情况下扩展功能
4. **拦截**：可以拦截和修改程序行为

### 示例代码：
```python
# 钩子函数示例
class Processor:
    def __init__(self):
        self.before_process_hooks = []
        self.after_process_hooks = []
    
    def add_before_hook(self, hook):
        """添加前置钩子"""
        self.before_process_hooks.append(hook)
    
    def add_after_hook(self, hook):
        """添加后置钩子"""
        self.after_process_hooks.append(hook)
    
    def process(self, data):
        """处理数据，执行钩子"""
        # 执行前置钩子
        for hook in self.before_process_hooks:
            hook(data)
        
        # 核心处理逻辑
        print(f"核心处理: {data}")
        result = data.upper()
        
        # 执行后置钩子
        for hook in self.after_process_hooks:
            hook(result)
        
        return result

# 钩子函数定义
def log_before(data):
    print(f"[前置钩子] 开始处理: {data}")

def log_after(result):
    print(f"[后置钩子] 处理结果: {result}")

# 使用钩子
processor = Processor()
processor.add_before_hook(log_before)
processor.add_after_hook(log_after)

processor.process("hello hooks")
```

### 输出：
```
[前置钩子] 开始处理: hello hooks
核心处理: hello hooks
[后置钩子] 处理结果: HELLO HOOKS
```

### 常见应用场景：
- 框架扩展点（Web框架中间件）
- 插件系统
- 调试和监控
- 权限检查
- 行为修改（如修改函数参数或返回值）

## 回调函数 vs 钩子函数

| 特性         | 回调函数                      | 钩子函数                      |
|--------------|-----------------------------|-----------------------------|
| **目的**     | 处理异步事件的结果           | 在特定点扩展或修改程序行为   |
| **调用方式** | 作为参数显式传递            | 在预设位置自动调用           |
| **控制权**   | 由被调用方控制              | 由系统或框架控制            |
| **数量**     | 通常一对一                  | 可多个钩子串联              |
| **应用场景** | 事件处理、异步操作          | 框架扩展、插件系统          |
| **时序**     | 在操作完成后调用            | 可在操作前、中、后调用      |
| **作用域**   | 针对特定操作                | 针对系统流程                |

## 实际应用中的组合使用

在实际开发中，回调函数和钩子函数经常结合使用：

```python
# 结合使用回调和钩子
class FileMonitor:
    def __init__(self):
        self.on_modified_callbacks = []
        self.before_monitor_hooks = []
    
    def add_callback(self, callback):
        """添加文件修改回调"""
        self.on_modified_callbacks.append(callback)
    
    def add_before_hook(self, hook):
        """添加监控前钩子"""
        self.before_monitor_hooks.append(hook)
    
    def start_monitoring(self, path):
        """开始监控文件"""
        # 执行前置钩子
        for hook in self.before_monitor_hooks:
            hook(path)
        
        print(f"开始监控路径: {path}")
        # 模拟文件修改事件
        self.simulate_file_change()
    
    def simulate_file_change(self):
        """模拟文件修改事件"""
        # 触发回调
        for callback in self.on_modified_callbacks:
            callback("/path/to/modified/file.txt")

# 钩子函数
def log_before_monitoring(path):
    print(f"[钩子] 即将监控路径: {path}")

# 回调函数
def handle_file_change(file_path):
    print(f"[回调] 文件已修改: {file_path}")

# 使用
monitor = FileMonitor()
monitor.add_before_hook(log_before_monitoring)
monitor.add_callback(handle_file_change)
monitor.start_monitoring("/data")
```

### 输出：
```
[钩子] 即将监控路径: /data
开始监控路径: /data
[回调] 文件已修改: /path/to/modified/file.txt
```

## 总结

1. **回调函数**：
    - 更注重异步操作的结果处理
    - 由被调用方在适当时机调用
    - 常用于事件驱动编程

2. **钩子函数**：
    - 更注重程序流程的扩展和修改
    - 在预设位置自动调用
    - 常用于框架和系统设计

两者都是实现松耦合和可扩展性的重要技术手段，理解它们的区别和适用场景可以帮助我们设计出更灵活、更易维护的系统架构。在实际开发中，它们经常相互配合使用，共同构建灵活的程序结构。