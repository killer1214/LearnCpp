# 观察者模式示例（C++实现）

下面是一个完整的观察者模式实现示例，使用智能指针管理对象生命周期，避免内存泄漏：

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <algorithm>

// 前置声明
class Subject;

// 观察者接口
class Observer : public std::enable_shared_from_this<Observer> {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
    virtual void subscribe(const std::shared_ptr<Subject>& subject) = 0;
    virtual void unsubscribe() = 0;
};

// 主题接口
class Subject {
public:
    virtual ~Subject() = default;
    virtual void attach(const std::weak_ptr<Observer>& observer) = 0;
    virtual void detach(const std::weak_ptr<Observer>& observer) = 0;
    virtual void notify(const std::string& message) = 0;
};

// 具体主题 - 气象站
class WeatherStation : public Subject {
    std::vector<std::weak_ptr<Observer>> observers;
    float temperature = 0.0f;
    float humidity = 0.0f;

public:
    void setMeasurements(float temp, float hum) {
        temperature = temp;
        humidity = hum;
        notify("Measurements updated");
    }

    void attach(const std::weak_ptr<Observer>& observer) override {
        observers.push_back(observer);
        std::cout << "Observer attached to WeatherStation\n";
    }

    void detach(const std::weak_ptr<Observer>& observer) override {
        auto it = std::remove_if(observers.begin(), observers.end(),
            [&](const std::weak_ptr<Observer>& w) {
                if (auto o1 = w.lock(), o2 = observer.lock()) {
                    return o1 == o2;
                }
                return false;
            });
        observers.erase(it, observers.end());
        std::cout << "Observer detached from WeatherStation\n";
    }

    void notify(const std::string& message) override {
        std::cout << "\nWeatherStation notifying " << observers.size() 
                  << " observers: " << message << "\n";
        
        // 使用临时容器存储有效的观察者
        std::vector<std::shared_ptr<Observer>> validObservers;
        
        for (auto& weak_obs : observers) {
            if (auto obs = weak_obs.lock()) {
                validObservers.push_back(obs);
            }
        }
        
        // 清理无效的观察者
        observers.erase(
            std::remove_if(observers.begin(), observers.end(),
                [](const std::weak_ptr<Observer>& w) {
                    return w.expired();
                }),
            observers.end());
        
        // 通知有效的观察者
        for (auto& obs : validObservers) {
            obs->update(message);
        }
    }

    float getTemperature() const { return temperature; }
    float getHumidity() const { return humidity; }
};

// 具体观察者 - 手机显示
class PhoneDisplay : public Observer {
    std::weak_ptr<Subject> weatherStation;
    std::string name;

public:
    explicit PhoneDisplay(const std::string& name) : name(name) {}

    void update(const std::string& message) override {
        if (auto station = weatherStation.lock()) {
            auto ws = dynamic_cast<WeatherStation*>(station.get());
            if (ws) {
                std::cout << "[" << name << "] Update received: " << message
                          << "\n  Temperature: " << ws->getTemperature()
                          << "°C, Humidity: " << ws->getHumidity() << "%\n";
            }
        }
    }

    void subscribe(const std::shared_ptr<Subject>& subject) override {
        weatherStation = subject;
        subject->attach(weak_from_this());
        std::cout << name << " subscribed to WeatherStation\n";
    }

    void unsubscribe() override {
        if (auto station = weatherStation.lock()) {
            station->detach(weak_from_this());
            weatherStation.reset();
            std::cout << name << " unsubscribed\n";
        }
    }

    ~PhoneDisplay() {
        unsubscribe();
        std::cout << name << " destroyed\n";
    }
};

// 具体观察者 - 电视显示
class TVDisplay : public Observer {
    std::weak_ptr<Subject> weatherStation;
    std::string name;

public:
    explicit TVDisplay(const std::string& name) : name(name) {}

    void update(const std::string& message) override {
        if (auto station = weatherStation.lock()) {
            auto ws = dynamic_cast<WeatherStation*>(station.get());
            if (ws) {
                std::cout << "[" << name << "] TV Display: Weather update!\n"
                          << "  Current temp: " << ws->getTemperature()
                          << "°C, Humidity: " << ws->getHumidity() << "%\n";
            }
        }
    }

    void subscribe(const std::shared_ptr<Subject>& subject) override {
        weatherStation = subject;
        subject->attach(weak_from_this());
        std::cout << name << " subscribed to WeatherStation\n";
    }

    void unsubscribe() override {
        if (auto station = weatherStation.lock()) {
            station->detach(weak_from_this());
            weatherStation.reset();
            std::cout << name << " unsubscribed\n";
        }
    }

    ~TVDisplay() {
        unsubscribe();
        std::cout << name << " destroyed\n";
    }
};

int main() {
    // 创建气象站主题
    auto weatherStation = std::make_shared<WeatherStation>();
    
    // 创建观察者
    auto phone1 = std::make_shared<PhoneDisplay>("John's Phone");
    auto phone2 = std::make_shared<PhoneDisplay>("Alice's Phone");
    auto tv = std::make_shared<TVDisplay>("Living Room TV");
    
    // 订阅
    phone1->subscribe(weatherStation);
    phone2->subscribe(weatherStation);
    tv->subscribe(weatherStation);
    
    // 更新气象数据
    weatherStation->setMeasurements(23.5f, 45.0f);
    
    // 取消一个订阅
    phone1->unsubscribe();
    
    // 更新气象数据
    weatherStation->setMeasurements(25.0f, 40.0f);
    
    // 创建临时观察者
    {
        auto tempPhone = std::make_shared<PhoneDisplay>("Temporary Phone");
        tempPhone->subscribe(weatherStation);
        weatherStation->setMeasurements(26.0f, 38.0f);
    } // tempPhone 离开作用域，自动取消订阅
    
    // 再次更新
    weatherStation->setMeasurements(22.0f, 50.0f);
    
    // 取消所有订阅
    phone2->unsubscribe();
    tv->unsubscribe();
    
    std::cout << "\nProgram ending...\n";
    return 0;
}
```

## 示例输出

```
John's Phone subscribed to WeatherStation
Observer attached to WeatherStation
Alice's Phone subscribed to WeatherStation
Observer attached to WeatherStation
Living Room TV subscribed to WeatherStation
Observer attached to WeatherStation

WeatherStation notifying 3 observers: Measurements updated
[John's Phone] Update received: Measurements updated
  Temperature: 23.5°C, Humidity: 45%
[Alice's Phone] Update received: Measurements updated
  Temperature: 23.5°C, Humidity: 45%
[Living Room TV] TV Display: Weather update!
  Current temp: 23.5°C, Humidity: 45%
Observer detached from WeatherStation
John's Phone unsubscribed

WeatherStation notifying 2 observers: Measurements updated
[Alice's Phone] Update received: Measurements updated
  Temperature: 25°C, Humidity: 40%
[Living Room TV] TV Display: Weather update!
  Current temp: 25°C, Humidity: 40%
Temporary Phone subscribed to WeatherStation
Observer attached to WeatherStation

WeatherStation notifying 3 observers: Measurements updated
[Temporary Phone] Update received: Measurements updated
  Temperature: 26°C, Humidity: 38%
[Alice's Phone] Update received: Measurements updated
  Temperature: 26°C, Humidity: 38%
[Living Room TV] TV Display: Weather update!
  Current temp: 26°C, Humidity: 38%
Observer detached from WeatherStation
Temporary Phone unsubscribed
Temporary Phone destroyed

WeatherStation notifying 2 observers: Measurements updated
[Alice's Phone] Update received: Measurements updated
  Temperature: 22°C, Humidity: 50%
[Living Room TV] TV Display: Weather update!
  Current temp: 22°C, Humidity: 50%
Observer detached from WeatherStation
Alice's Phone unsubscribed
Observer detached from WeatherStation
Living Room TV unsubscribed

Program ending...
Alice's Phone destroyed
Living Room TV destroyed
John's Phone destroyed
```

## 观察者模式关键点解析

### 1. 智能指针的使用
- **`weak_ptr` 用于主题存储观察者**：避免循环引用，允许观察者被销毁
- **`shared_ptr` 用于对象所有权**：确保对象生命周期正确管理
- **`enable_shared_from_this`**：允许观察者安全获取自身的 `weak_ptr`

### 2. 核心组件
- **Subject（主题）**：
    - 维护观察者列表（使用 `weak_ptr`）
    - 提供注册/注销接口
    - 状态变化时通知所有观察者

- **Observer（观察者）**：
    - 定义更新接口
    - 实现具体的更新行为
    - 管理对主题的订阅关系

### 3. 生命周期管理技巧
1. **自动取消订阅**：在观察者析构函数中调用 `unsubscribe()`
2. **清理无效观察者**：主题通知时自动清理已销毁的观察者
3. **作用域管理**：使用块作用域控制临时观察者生命周期

### 4. 线程安全考虑
- 示例中未处理线程安全（简化实现）
- 实际应用中需要添加互斥锁保护：
    - 观察者列表访问
    - 通知过程中的状态变更

### 5. 模式优点
1. **松耦合**：主题和观察者独立变化
2. **动态关系**：运行时添加/移除观察者
3. **广播通信**：一对多通知机制
4. **符合开闭原则**：新增观察者不影响主题

## 使用场景

1. **GUI事件处理**：按钮点击通知多个处理程序
2. **消息推送系统**：消息中心通知多个订阅者
3. **游戏引擎**：角色状态变化通知UI元素
4. **股票交易系统**：股价变动通知多个交易终端
5. **分布式系统**：配置变更通知所有服务节点

这个示例展示了如何在现代C++中实现观察者模式，充分利用智能指针管理资源，避免内存泄漏和循环引用问题，同时保持代码的清晰和可维护性。