在 C++ 中，**纯虚函数（Pure Virtual Function）** 是一种特殊的虚函数，它强制派生类必须提供自己的实现。包含纯虚函数的类称为**抽象类（Abstract Class）**，不能直接实例化。

### 核心概念
1. **语法**：在虚函数声明末尾添加 `= 0`
   ```cpp
   virtual 返回类型 函数名(参数) = 0;
   ```

2. **抽象类**：
    - 至少包含一个纯虚函数
    - 不能创建对象（`Shape s;` 会报错）
    - 用于定义接口规范

3. **派生类要求**：
    - 必须重写（实现）所有纯虚函数
    - 否则派生类也会变成抽象类

---

### 使用示例
```cpp
#include <iostream>
#include <vector>

// 抽象基类：定义图形接口
class Shape {
public:
    // 纯虚函数：计算面积
    virtual double area() const = 0;

    // 纯虚函数：打印信息
    virtual void print() const = 0;

    // 虚析构函数（必需！）
    virtual ~Shape() = default;
};

// 派生类：圆形
class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}

    // 必须实现基类纯虚函数
    double area() const override {
        return 3.14159 * radius * radius;
    }

    void print() const override {
        std::cout << "Circle: radius=" << radius 
                  << ", area=" << area() << "\n";
    }
};

// 派生类：矩形
class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}

    // 实现基类纯虚函数
    double area() const override {
        return width * height;
    }

    void print() const override {
        std::cout << "Rectangle: " << width << "x" << height
                  << ", area=" << area() << "\n";
    }
};

int main() {
    // Shape s;  // 错误：不能实例化抽象类

    // 通过基类指针操作派生类对象
    std::vector<Shape*> shapes;
    shapes.push_back(new Circle(5.0));
    shapes.push_back(new Rectangle(4.0, 6.0));

    // 多态调用
    for (Shape* s : shapes) {
        s->print();    // 调用各自派生类的实现
        std::cout << "Area: " << s->area() << "\n\n";
    }

    // 清理内存
    for (Shape* s : shapes) delete s;
}
```

**输出**：
```
Circle: radius=5, area=78.5397
Area: 78.5397

Rectangle: 4x6, area=24
Area: 24
```

---

### 关键用途
1. **定义接口规范**  
   强制派生类实现特定功能（如示例中的 `area()` 和 `print()`）

2. **实现多态**  
   通过基类指针/引用调用不同派生类的实现

3. **构建框架**  
   设计模式（如工厂模式、策略模式）的基础构件

---

### 注意事项
1. **必须提供虚析构函数**  
   基类中声明 `virtual ~Shape() = default;`  
   （确保通过基类指针删除派生类对象时正确调用析构函数）

2. **纯虚函数可以有实现**（但不常用）
   ```cpp
   // 基类声明
   virtual void debug() const = 0;

   // 单独的实现（派生类仍必须重写）
   void Shape::debug() const { 
       std::cout << "Base debug\n"; 
   }
   ```

3. **C++11 引入 `override` 关键字**  
   明确表示重写虚函数，增强代码可读性和安全性

---

### 总结
| 特性         | 纯虚函数                     | 普通虚函数             |
|--------------|-----------------------------|-----------------------|
| **语法**     | `virtual func() = 0;`       | `virtual func();`     |
| **基类实现** | 可选（通常无）              | 必须有                |
| **派生类**   | 必须重写                    | 可选重写             |
| **类类型**   | 使类成为抽象类              | 普通类               |
| **用途**     | 强制接口规范                | 提供默认实现         |

通过纯虚函数，C++ 实现了运行时的多态性，同时保证了接口的强制性，这是面向对象设计中“依赖倒置原则”的关键实现机制。