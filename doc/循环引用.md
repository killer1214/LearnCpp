### 循环引用问题详解（以 `std::shared_ptr` 为例）

循环引用通常发生在使用 **共享所有权智能指针**（如 `std::shared_ptr`）时，当两个或多个对象相互持有对方的 `shared_ptr`，导致引用计数无法归零，从而引发内存泄漏。虽然 `std::unique_ptr` 本身不会直接导致循环引用（因为它是独占所有权），但理解这个概念对智能指针使用至关重要。

---

#### 循环引用示例
```cpp
#include <memory>
#include <iostream>

class Child;  // 前向声明

class Parent {
public:
    std::shared_ptr<Child> child;  // 持有 Child 的共享指针
    ~Parent() { std::cout << "Parent destroyed\n"; }
};

class Child {
public:
    std::shared_ptr<Parent> parent;  // 持有 Parent 的共享指针 ❌
    ~Child() { std::cout << "Child destroyed\n"; }
};

int main() {
    {
        auto parent = std::make_shared<Parent>();
        auto child = std::make_shared<Child>();
        
        parent->child = child;   // Parent 持有 Child
        child->parent = parent;  // Child 持有 Parent → 形成循环引用
    }  // 离开作用域时，对象不会被销毁！

    // 输出：无任何析构信息 → 内存泄漏
    return 0;
}
```

---

#### 内存泄漏原因分析
| 对象      | 初始引用计数 | 相互引用后 | 离开作用域后 |
|-----------|--------------|------------|--------------|
| `parent`  | 1            | 2 (被 `child` 持有) | 1            |
| `child`   | 1            | 2 (被 `parent` 持有) | 1            |

- **问题本质**：  
  两个对象的引用计数永远无法归零 → 资源无法释放。

---

### 解决方案：使用 `std::weak_ptr`
`std::weak_ptr` 是一种 **不增加引用计数** 的智能指针，专门用于解决循环引用问题。

#### 修正后的代码
```cpp
class ChildFixed {
public:
    std::weak_ptr<Parent> parent;  // 使用 weak_ptr 代替 shared_ptr ✅
    ~ChildFixed() { std::cout << "Child destroyed\n"; }
};

int main() {
    {
        auto parent = std::make_shared<Parent>();
        auto child = std::make_shared<ChildFixed>();
        
        parent->child = child;
        child->parent = parent;  // weak_ptr 不增加引用计数
    }  // 离开作用域时对象正常销毁

    // 输出：
    // Parent destroyed
    // Child destroyed
    return 0;
}
```

---

#### 关键机制解析
1. **`weak_ptr` 不增加引用计数**
    - 当 `child->parent` 使用 `weak_ptr` 时，`parent` 的引用计数保持为 **1**（仅由 `parent` 变量持有）。
    - 离开作用域时：
        - `parent` 引用计数归零 → 销毁 `Parent` 对象
        - 销毁过程中释放 `parent->child` → `child` 引用计数归零 → 销毁 `Child` 对象

2. **安全访问对象**  
   通过 `lock()` 方法获取可用的 `shared_ptr`：
   ```cpp
   if (auto valid_ptr = child->parent.lock()) {
       valid_ptr->do_something();  // 安全操作
   } else {
       std::cout << "Parent already destroyed\n";
   }
   ```

---

### `std::unique_ptr` 与循环引用的关系
虽然 `unique_ptr` 本身**不会导致循环引用**（因为它是独占所有权），但在复杂对象关系中仍需注意：

#### 可能的陷阱场景
```cpp
class Node {
    std::unique_ptr<Node> next;  // 独占下一个节点
    Node* prev;                  // 指向上一个节点（原始指针）
};

void cyclic_risk() {
    auto node1 = std::make_unique<Node>();
    auto node2 = std::make_unique<Node>();

    node1->next = std::move(node2);  // node1 接管 node2
    node2->prev = node1.get();       // node2 持有 node1 的裸指针 ✅

    // 安全：node1 销毁时自动销毁 node2
    // 但需确保 prev 不会在 node1 之后被误用
}
```

#### 设计原则
1. **所有权单向化**
    - 使用 `unique_ptr` 表示 **独占所有权**（如 `next` 指针）
    - 使用 **原始指针** 或 `weak_ptr` 表示 **非所有权引用**（如 `prev` 指针）

2. **生命周期管理**
    - 确保被观察对象（如 `node1`）的生命周期长于观察者（如 `node2`）

---

### 关键总结
| 指针类型          | 循环引用风险 | 解决方案               |
|-------------------|--------------|------------------------|
| `std::shared_ptr` | 高           | 用 `weak_ptr` 打破循环 |
| `std::unique_ptr` | 无           | 配合原始指针/`weak_ptr` |

**最佳实践**：
- 默认使用 `unique_ptr`（避免共享所有权）
- 必须共享时，检查对象关系图是否成环
- 成环时用 `weak_ptr` 替代单向引用