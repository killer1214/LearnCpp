这段代码使用C++标准库中的`for_each`算法遍历容器`numbers`中的所有元素，并通过lambda表达式筛选并输出其中的偶数。以下是详细解释：

### 代码分解：
```cpp
for_each(numbers.begin(), numbers.end(), [](int n) {
    if (n % 2 == 0) cout << n << " ";
});
```
1. **`for_each`算法**：
    - **作用**：遍历指定范围内的每个元素，并对每个元素执行给定的操作。
    - **参数**：
        - `numbers.begin()`：容器起始迭代器
        - `numbers.end()`：容器终止迭代器（末尾的后一位）
        - **Lambda表达式**：定义对每个元素的操作

2. **Lambda表达式**：
   ```cpp
   [](int n) {
       if (n % 2 == 0) cout << n << " ";
   }
   ```
    - **功能**：检查整数`n`是否为偶数（`n % 2 == 0`），如果是则输出该数和一个空格。
    - **执行过程**：`for_each`将`numbers`中的每个元素依次传递给lambda的形参`n`，执行条件判断和输出。

---

### Lambda表达式的固定写法：
Lambda表达式的基本语法如下：
```cpp
[capture-list] (parameters) -> return_type { 
    // 函数体
}
```

#### 1. **捕获列表 `[capture-list]`**（可选）
- 定义lambda如何访问外部变量：
    - `[]`：不捕获任何外部变量（本例中使用此方式）
    - `[var]`：按值捕获变量`var`
    - `[&var]`：按引用捕获变量`var`
    - `[=]`：按值捕获所有外部变量
    - `[&]`：按引用捕获所有外部变量
    - `[this]`：捕获当前类的`this`指针

#### 2. **参数列表 `(parameters)`**（可选）
- 与普通函数参数列表相同，例如：
    - `()`：无参数
    - `(int x, double y)`：带类型参数
    - **本例中**：`(int n)` 接收容器中的整数元素

#### 3. **返回类型 `-> return_type`**（可选）
- 可省略（编译器自动推导），复杂逻辑需显式声明：
    - `-> bool`：返回布尔类型
    - **本例中**：无返回值（`void`），故省略

#### 4. **函数体 `{ ... }`**
- 包含要执行的代码逻辑（本例中：条件判断和输出）

---

### 关键特性：
1. **无捕获**：  
   本例使用`[]`，表示不依赖外部变量，仅使用传入的参数`n`。
2. **隐式返回类型**：  
   函数体只有一条条件输出语句，无`return`，编译器推导返回类型为`void`。
3. **典型应用场景**：  
   简单逻辑（如遍历、筛选、输出），替代单独定义函数，提升代码紧凑性。

---

### 等效普通函数实现：
若用普通函数重写相同逻辑：
```cpp
void printEven(int n) {
    if (n % 2 == 0) 
        cout << n << " ";
}

// 调用
for_each(numbers.begin(), numbers.end(), printEven);
```
lambda的优势在于**无需预先定义函数**，直接将逻辑内联在调用处。

---

### 总结：
- **代码作用**：输出容器`numbers`中的所有偶数，空格分隔。
- **Lambda要点**：
    - 固定结构：`[] () { }`
    - 按需选择捕获方式（本例无需捕获）
    - 参数和返回类型可省略（由编译器推导）
- **适用场景**：简化短小的临时操作，增强代码可读性和编写效率。